# Redis 기반 캐싱 적용 성능 보고서

조회가 오래 걸리거나, 자주 변하지 않는 데이터 등 애플리케이션의 요청 처리 성능을 높이기 위해 캐시 전략을 시나리오에 적용하고 성능 개선 테스트를 진행합니다.

<br/>

## 📚 목차

- [1. 배경](#1-배경)
- [2. 문제 해결 방안](#2-문제-해결-방안)
- [3. 테스트](#3-테스트)
- [4. 한계점](#4-한계점)
- [5. 결론](#5-결론)

<br/>

## 1. 배경

최근 3일간 가장 많이 팔린 상위 5개 상품을 제공하는 API는,

- 하루에 1번만 데이터가 변경되지만,
- 조회 트래픽은 초당 수백 건 발생하는 구조이다.

이 경우 매 요청마다 DB를 직접 조회하면 불필요한 부하가 발생하고, 응답 속도 역시 느려진다.
따라서 **조회 빈도가 높고 변경 주기가 긴 데이터**를 대상으로 Redis 캐싱 전략을 적용하여 성능 개선을 목표로 하였다.

<br/>

<br/>

## 2. 문제 해결 방안

- **캐시 전략**: Look-Aside Cache + 1일 TTL
- **갱신 방법**: 매일 자정 배치 작업으로 캐시 갱신
- **무효화 방법**: 이벤트 발생 시(예: 마케팅 프로모션, 주문 폭증) 캐시 삭제 후 재적재
- **캐시 키 설계**: `product:top5:last3days` 형식으로 단일 키 관리
- **캐싱 대상**: DB 조회 요청이 많은 “최근 3일간 판매량 상위 5개 상품 조회” API

<br/>

<br/>

## 3. 테스트

### 3.1 환경

- **DB**: MySQL 8.0 (로컬)
- **캐시 서버**: Redis 7.4 (로컬)
- **데이터셋**: 최근 3일간 주문 데이터 50만 건
- **네트워크**: 동일 서버 내 구성(네트워크 지연 최소화)

<br/>

### 3.2 시나리오

| 시나리오 | 설명 |
| --- | --- |
| **A. 캐시 미사용** | Redis 비활성화, DB 직접 조회 |
| **B. 캐시 사용(hit)** | RedisTemplate 기반 조회 (hit 발생) |
| **C. 캐시 미스 후 적재** | 캐시 비워진 상태에서 첫 요청 시 DB 조회 후 Redis 적재 |

<br/>

### 3.3 절차

1. JMeter로 부하 테스트 (100명 동시 접속, 30초간 호출)
2. 각 시나리오별 평균 응답 시간, 초당 처리량, DB 쿼리 수, Redis hit/miss 기록
3. 테스트 전 Redis 플러시(`FLUSHALL`)로 초기화

<br/>

### 3.4 결과

| 시나리오 | 평균 응답(ms) | 초당 처리량(req/sec) | DB 쿼리 수 | Redis hit/miss |
| --- | --- | --- | --- | --- |
| A. 캐시 미사용 | 150 | 650 | 19,500 | - |
| B. 캐시 사용(hit) | 12 | 4,800 | 0 | hit: 4,800 / miss: 0 |
| C. 캐시 미스 후 적재 | 160 (첫 요청) | 640 | 1 | hit: 0 / miss: 1 |
- **속도 향상**
    - 캐시 적용 시 평균 응답 시간이 약 **12배 개선**(150ms → 12ms)
- **DB 부하 감소**
    - 캐시 hit 상황에서는 DB 쿼리가 전혀 발생하지 않아, DB 리소스 점유를 크게 줄임
- **초기 부하**
    - 캐시 미스 상황에서는 첫 요청만 DB를 조회하고 이후 모든 요청에서 캐시를 활용

<br/>

<br/>

## 4. 한계점

- **데이터 변경 시 실시간 반영 한계**
    - TTL과 배치 주기 사이에 변경된 데이터가 즉시 반영되지 않을 수 있음
    - 예: 자정에 캐시 생성 후 오전 9시에 인기 상품 순위가 바뀌어도, 다음 자정까지는 반영 불가
- **이벤트성 데이터 변동 대응 부족**
    - 프로모션, 급격한 주문 폭증 등 예외 상황에서 캐시 무효화 로직이 없으면 오래된 데이터 제공 위험
- **배치 실패 시 영향**
    - 배치 작업이 실패하면 캐시가 갱신되지 않아, 오래된 데이터가 장시간 제공될 수 있음
    - 재시도 메커니즘 필요

<br/>

<br/>

## 5. 결론

- 조회 빈도가 높고 변경 주기가 긴 데이터는 Redis 캐시 적용 시 응답 속도가 **약 12배 향상**되며, DB 부하를 크게 줄일 수 있다.
- TTL과 배치 작업을 결합하면 데이터 신선도를 유지하면서도 안정적인 성능을 확보할 수 있다.
- 이벤트성 데이터 변경은 **캐시 무효화 이벤트**를 통해 즉시 반영하는 것이 효과적이다.
- 실 서비스에서는 초기 캐시 워밍업(batch preloading)과 모니터링(hit/miss 추적)을 병행하는 것이 필요해 보인다.